% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_data.R
\name{filter_data}
\alias{filter_data}
\title{Filter Data}
\usage{
filter_data(
  x,
  method = c("smooth-spline", "butterworth", "moving-average"),
  type = c("low", "high", "stop", "pass"),
  spar = NULL,
  n = 1,
  W,
  fc,
  sample_rate,
  width,
  na.rm = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{x}{A numeric vector.}

\item{method}{Indicates how to filter the data (see \emph{Details}).
\describe{
\item{\code{"smooth-spline"}}{fits a cubic smoothing spline.}
\item{\code{"butterworth"}}{uses a centred Butterworth digital filter. \code{type} should
be defined (see \emph{Details}).}
\item{\code{"moving-average"}}{uses a centred moving average filter.}
}}

\item{type}{Specify the filter type. \emph{Only relevant for \code{method = "butterworth"}}
(see \emph{Details}).
\describe{
\item{\code{"low"}}{For a \emph{low-pass} filter (\emph{default}).}
\item{\code{"high"}}{For a \emph{high-pass} filter.}
\item{\code{"stop"}}{For a \emph{stop-band} (band-reject) filter.}
\item{\code{"pass"}}{For a \emph{pass-band} filter.}
}}

\item{spar}{A numeric scalar defining the smoothing parameter for
\code{method = "smooth-spline"}.}

\item{n}{An integer scalar defining the order of a Butterworth filter for
\code{method = "butterworth"}.}

\item{W}{A numeric scalar or two-element vector defining the fractional
critical frequency(ies) of a Butterworth filter for \code{method = "butterworth"}.}

\item{fc}{A numeric scalar or two-element vector defining the critical
frequency(ies) of a Butterworth filter for \code{method = "butterworth"}.}

\item{sample_rate}{A numeric scalar for the sample rate in Hz for
\code{method = "butterworth"}.}

\item{width}{A numeric scalar defining the window length of samples for
\code{method = "moving-average"}.}

\item{na.rm}{A logical indicating whether missing values should be ignored
(\code{TRUE}) before the filter is applied. Otherwise (\code{FALSE}, the \emph{default}) will
throw an error (see \emph{Details}).}

\item{verbose}{A logical. \code{TRUE} (the \emph{default}) will return warnings and
messages which can be used for troubleshooting. \code{FALSE} will silence these
messages. Errors will always be returned.}
}
\value{
A numeric vector of filtered data.
}
\description{
Apply signal filtering to vector data with either: 1. A cubic smoothing spline.
2. A Butterworth digital filter. 3. A simple moving average.
}
\details{
\describe{
\item{\code{method = "smooth-spline"}}{applies a non-parametric cubic
smoothing spline from \code{\link[stats:smooth.spline]{stats::smooth.spline()}}. Smoothing is defined
by the parameter \code{spar}, which can be left blank and automatically
determined via penalised log liklihood. This usually works well for
smoothing responses occurring on the order of minutes or longer. Or \code{spar}
can be defined explicitly, typically (but not necessarily) in the range
\verb{spar = [0, 1]}.}
\item{\code{method = "butterworth"}}{applies a centred (two-pass symmetrical)
Butterworth digital filter from \code{\link[signal:butter]{signal::butter()}} and \code{\link[signal:filtfilt]{signal::filtfilt()}}.
The filter order is defined by \code{n}, typically in the range \verb{n = [1, 10]}.
Higher filter orders tend to better capture rapid changes in amplitude,
but also cause more distortion artefacts in the signal. General advice is
to use the lowest order which sufficiently captures any rapid step-changes
in the data.

Filter \code{type} defines how the desired signal frequencies are either passed
through or rejected from the output signal. \emph{Low-pass} and \emph{high-pass}
filters allow only frequencies \emph{lower} or \emph{higher} than the critical
frequency \code{W} to be passed through as the output signal, respectively.
\emph{Stop-band} defines a critical range of frequencies which are rejected
from the output signal. \emph{Pass-band} defines a critical range of frequencies
which are passed through as the output signal.

The critical (cutoff) frequency is defined by \code{W}, a numeric scalar for
\emph{low-pass} and \emph{high-pass} filters, or a two-element vector \code{c(low, high)}
defining the lower and upper bands for \emph{stop-band} and \emph{pass-band} filters.
\code{W} represents the desired fractional critical frequency in the range
\verb{W = [0, 1]}, where \code{1} is the Nyquist frequency, i.e., half the sample
rate of the data in Hz.

Alternatively, the critical frequency can be defined by \code{fc}
and \code{sample_rate} together. \code{fc} represents the desired
critical frequency in Hz, and \code{sample_rate} is the sample rate of the
recorded data in Hz. \code{W = fc / (sample_rate/2)}.

Defining both \code{fc} and \code{sample_rate} explicitly will
overwrite \code{W}.}
\item{\code{method = "moving-average"}}{applies a centred (two-way symmetrical)
moving average filter from \code{\link[zoo:rollapply]{zoo::rollapply()}}. The moving-average is
calculated over a window of width \code{width} defining the number of samples
between \verb{[i - floor(width/2), i + floor(width/2)]}. A partial moving-
average will be calculated at the edges of the existing data.}
}

Missing values (\code{NA}) in the numeric vector will cause an error unless
\code{na.rm = TRUE}. Then \code{NA} values are removed for processing, and restored in
the returned vector.
}
\examples{
set.seed(13)
n <- 500
x <- seq(0, 2*pi, len = n)
y_clean <- 2*sin(x)
noise <- rnorm(n, mean = 0, sd = 0.5)
y <- y_clean + noise

y.spline <- filter_data(y, method = "smooth-spline")
y.LP <- filter_data(y, method = "butterworth", n = 2, W = 0.05)
y.MA <- filter_data(y, method = "moving-average", width = 30)

\dontrun{
plot(x, y)
lines(x, y.spline, lwd = 2, col = "blue")
lines(x, y.LP, lwd = 2, col = "red")
lines(x, y.MA, lwd = 2, col = "green4")
}

}
