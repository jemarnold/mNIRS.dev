[{"path":"https://jemarnold.github.io/mNIRS.dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 mNIRS authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"read-data-from-file","dir":"Articles","previous_headings":"","what":"Read Data From File","title":"Processing Data with {mNIRS}","text":"read example data file two NIRS channels, recording incremental ramp cycling assessment. example NIRS data files included mNIRS package. First, load mNIRS package required libraries. mNIRS can installed devtools::install_github(\"jemarnold/mNIRS\"). file_path: need specify file path read . e.g. r(\"C:\\myfolder\\mNIRS_file.xlsx\"). read file_path included example data file. Now can read data file read_data() function. function take raw NIRS data exported device, return dataframe data channels specify. See ?read_data details. need tell function column names look , identify data table file. data table may top file, column names can anywhere file. nirs_columns: minimum, need one column name defined NIRS data. sample_column: Typically, also specify column time sample number observation. event_column: can specify column indicate laps specific events dataset. names quotations exactly match column headers file (case- special character-sensitive). Multiple columns can accepted nirs_columns. can rename columns importing data format: sample_rate: sample rate NIRS recording can specified known, number samples per second, Hz. left blank, function estimate sample rate sample_column, assuming contains time values. numeric_time: sample_column date-time format (e.g. hh:mm:ss), can convert numeric numeric_time = TRUE. may read date-time format starting non-zero value. can manually corrected later basic data wrangling. keep_all: data table file identified, default return columns names explicitly specified . want return columns data table, can set keep_all = TRUE. verbose: Finally, function may return warnings messages, example duplicate values sample_column may indicate recording issue. informative messages can useful data validation, can silenced verbose = TRUE. Fail-state errors always returned.","code":"library(dplyr) ## load for data wrangling library(ggplot2) ## load for plotting library(mNIRS)  # devtools::install_github(\"jemarnold/mNIRS\") ## install development version file_path <- system.file(\"extdata/moxy_ramp_example.xlsx\", package = \"mNIRS\") nirs_columns = c(new_name1 = \"file_column_name1\",                  new_name2 = \"file_column_name2\") data_raw <- read_data(file_path,                       nirs_columns = c(smo2_left = \"SmO2 Live\",                                        smo2_right = \"SmO2 Live(2)\"),                       sample_column = c(time = \"hh:mm:ss\"),                       event_column = c(lap = \"Lap\"),                       sample_rate = 2, ## we know this file is recorded at 2 samples per second                       numeric_time = TRUE, ## to convert the date-time string to numeric                       keep_all = FALSE, ## to keep the returned dataframe clean                       verbose = TRUE) ## show warnings & messages, but ignore them for now #> Warning: `sample_column = time` has non-sequential or repeating values. #> ℹ Consider investigating at \"time = 211.99, 211.99, 211.99, 1184, and 1184\".  ## ignore the Warning about repeated samples here  data_raw #> # A tibble: 2,203 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1  0        1        54         68 #>  2  0.4      1        54         68 #>  3  0.96     1        54         68 #>  4  1.51     1        54         66 #>  5  2.06     1        54         66 #>  6  2.61     1        54         66 #>  7  3.16     1        54         66 #>  8  3.71     1        57         67 #>  9  4.26     1        57         67 #> 10  4.81     1        57         67 #> # ℹ 2,193 more rows"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"specify-file-path","dir":"Articles","previous_headings":"","what":"Specify file path","title":"Processing Data with {mNIRS}","text":"file_path: need specify file path read . e.g. r(\"C:\\myfolder\\mNIRS_file.xlsx\"). read file_path included example data file. Now can read data file read_data() function. function take raw NIRS data exported device, return dataframe data channels specify. See ?read_data details.","code":"file_path <- system.file(\"extdata/moxy_ramp_example.xlsx\", package = \"mNIRS\")"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"specify-column-names","dir":"Articles","previous_headings":"","what":"Specify column names","title":"Processing Data with {mNIRS}","text":"need tell function column names look , identify data table file. data table may top file, column names can anywhere file. nirs_columns: minimum, need one column name defined NIRS data. sample_column: Typically, also specify column time sample number observation. event_column: can specify column indicate laps specific events dataset. names quotations exactly match column headers file (case- special character-sensitive). Multiple columns can accepted nirs_columns. can rename columns importing data format:","code":"nirs_columns = c(new_name1 = \"file_column_name1\",                  new_name2 = \"file_column_name2\")"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"other-read_data-options","dir":"Articles","previous_headings":"","what":"Other read_data() options","title":"Processing Data with {mNIRS}","text":"sample_rate: sample rate NIRS recording can specified known, number samples per second, Hz. left blank, function estimate sample rate sample_column, assuming contains time values. numeric_time: sample_column date-time format (e.g. hh:mm:ss), can convert numeric numeric_time = TRUE. may read date-time format starting non-zero value. can manually corrected later basic data wrangling. keep_all: data table file identified, default return columns names explicitly specified . want return columns data table, can set keep_all = TRUE. verbose: Finally, function may return warnings messages, example duplicate values sample_column may indicate recording issue. informative messages can useful data validation, can silenced verbose = TRUE. Fail-state errors always returned.","code":"data_raw <- read_data(file_path,                       nirs_columns = c(smo2_left = \"SmO2 Live\",                                        smo2_right = \"SmO2 Live(2)\"),                       sample_column = c(time = \"hh:mm:ss\"),                       event_column = c(lap = \"Lap\"),                       sample_rate = 2, ## we know this file is recorded at 2 samples per second                       numeric_time = TRUE, ## to convert the date-time string to numeric                       keep_all = FALSE, ## to keep the returned dataframe clean                       verbose = TRUE) ## show warnings & messages, but ignore them for now #> Warning: `sample_column = time` has non-sequential or repeating values. #> ℹ Consider investigating at \"time = 211.99, 211.99, 211.99, 1184, and 1184\".  ## ignore the Warning about repeated samples here  data_raw #> # A tibble: 2,203 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1  0        1        54         68 #>  2  0.4      1        54         68 #>  3  0.96     1        54         68 #>  4  1.51     1        54         66 #>  5  2.06     1        54         66 #>  6  2.61     1        54         66 #>  7  3.16     1        54         66 #>  8  3.71     1        57         67 #>  9  4.26     1        57         67 #> 10  4.81     1        57         67 #> # ℹ 2,193 more rows"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"data-wrangling","dir":"Articles","previous_headings":"","what":"Data wrangling","title":"Processing Data with {mNIRS}","text":"Note time column start zero, converted hh:mm:ss. Let’s quickly fix , ’ll plot data. can data wrangling steps , data file. prefer use tidyverse dataframe wrangling.  Dataframes read processed mNIRS functions return class = mNIRS.data contain metadata, can retrieved attributes(data). Instead re-defining column names sample rate, can call metadata. mNIRS functions automatically retrieve metadata present.","code":"data_time_fixed <- data_raw |>      mutate(time = time - first(time))  ## {mNIRS} data can be plotted with a built in call to `plot()` plot(data_time_fixed) nirs_columns <- attributes(data_raw)$nirs_columns nirs_columns #> [1] \"smo2_left\"  \"smo2_right\"  sample_rate <- attributes(data_raw)$sample_rate sample_rate #> [1] 2"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"metadata-stored-in-mnirs-data-dataframes","dir":"Articles","previous_headings":"","what":"Metadata stored in mNIRS.data dataframes","title":"Processing Data with {mNIRS}","text":"Dataframes read processed mNIRS functions return class = mNIRS.data contain metadata, can retrieved attributes(data). Instead re-defining column names sample rate, can call metadata. mNIRS functions automatically retrieve metadata present.","code":"nirs_columns <- attributes(data_raw)$nirs_columns nirs_columns #> [1] \"smo2_left\"  \"smo2_right\"  sample_rate <- attributes(data_raw)$sample_rate sample_rate #> [1] 2"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"replace-outliers-invalid-values-and-missing-values","dir":"Articles","previous_headings":"","what":"Replace Outliers, invalid Values, and Missing Values","title":"Processing Data with {mNIRS}","text":"can see errors data signals, let’s clean . can simple data wrangling steps clean invalid data prepare digital filtering smoothing. x: three replace_* functions work vector data; take single data channel (x), apply processing channel, return vector processed channel data. can identify local outliers using Hampel filter replace local median value. See ?replace_outliers details. width: number samples (window) detect local outliers. define window seconds, multiply desired number seconds sample rate. t0: number standard deviations outside detected outliers, defaulting 3 (Pearson’s rule). na.rm: TRUE/FALSE value indicating whether missing values (NA) ignored Hampel filter applied. return: Indicates whether outliers replaced local “median” value “NA”. Note relatively low sample rates, 2 Hz file, outlier filters may occasionally -filter ‘flatten’ sections data. observed example near end file, data trend quite flat already. NIRS devices recording software can report specific invalid values, c(0, 100, 102.3). can manually removed replace_invalid(). See ?replace_invalid details. values: vector numeric values replaced. width: number samples (window) local median calculated. define window seconds, multiply desired number seconds sample rate. return: Indicates whether invalid values replaced local “median” value “NA”. Finally, can use replace_missing() interpolate across missing data. fill methods available, see ?replace_missing details. method: Specify method filling missing data. default “linear” interpolation usually sufficient. na.rm: TRUE/FALSE value indicating leading trailing NAs remain processing, included omitted. maxgap: Specify maximum number consecutive NAs fill. longer gaps left unchanged. Subsequent processing & analysis steps may return errors missing values present. Therefore, good habit identify deal early data processing.  got rid obvious data issues.","code":"data_cleaned <- data_time_fixed |>      mutate(         across(any_of(nirs_columns), ## apply function across all of our `nirs_columns`                \\(.x) replace_outliers(x = .x,                                       width = 20 * sample_rate, ## 20 sec window                                       na.rm = TRUE, ## ignore `NA`                                       return = \"median\")         ),         across(any_of(nirs_columns),                 \\(.x) replace_invalid(x = .x,                                      values = c(0, 100), ## known invalid values                                      width = 20 * sample_rate,                                      return = \"NA\")         ),                  across(any_of(nirs_columns),                 \\(.x) replace_missing(x = .x,                                      method = \"linear\", ## linear interpolation                                      na.rm = FALSE, ## to preserve the length of the vector                                      maxgap = Inf) ## interpolate across gaps of any length         ),     )  plot(data_cleaned)"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"replace_outliers","dir":"Articles","previous_headings":"","what":"replace_outliers()","title":"Processing Data with {mNIRS}","text":"can identify local outliers using Hampel filter replace local median value. See ?replace_outliers details. width: number samples (window) detect local outliers. define window seconds, multiply desired number seconds sample rate. t0: number standard deviations outside detected outliers, defaulting 3 (Pearson’s rule). na.rm: TRUE/FALSE value indicating whether missing values (NA) ignored Hampel filter applied. return: Indicates whether outliers replaced local “median” value “NA”. Note relatively low sample rates, 2 Hz file, outlier filters may occasionally -filter ‘flatten’ sections data. observed example near end file, data trend quite flat already.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"replace_invalid","dir":"Articles","previous_headings":"","what":"replace_invalid()","title":"Processing Data with {mNIRS}","text":"NIRS devices recording software can report specific invalid values, c(0, 100, 102.3). can manually removed replace_invalid(). See ?replace_invalid details. values: vector numeric values replaced. width: number samples (window) local median calculated. define window seconds, multiply desired number seconds sample rate. return: Indicates whether invalid values replaced local “median” value “NA”.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"replace_missing","dir":"Articles","previous_headings":"","what":"replace_missing()","title":"Processing Data with {mNIRS}","text":"Finally, can use replace_missing() interpolate across missing data. fill methods available, see ?replace_missing details. method: Specify method filling missing data. default “linear” interpolation usually sufficient. na.rm: TRUE/FALSE value indicating leading trailing NAs remain processing, included omitted. maxgap: Specify maximum number consecutive NAs fill. longer gaps left unchanged. Subsequent processing & analysis steps may return errors missing values present. Therefore, good habit identify deal early data processing.  got rid obvious data issues.","code":"data_cleaned <- data_time_fixed |>      mutate(         across(any_of(nirs_columns), ## apply function across all of our `nirs_columns`                \\(.x) replace_outliers(x = .x,                                       width = 20 * sample_rate, ## 20 sec window                                       na.rm = TRUE, ## ignore `NA`                                       return = \"median\")         ),         across(any_of(nirs_columns),                 \\(.x) replace_invalid(x = .x,                                      values = c(0, 100), ## known invalid values                                      width = 20 * sample_rate,                                      return = \"NA\")         ),                  across(any_of(nirs_columns),                 \\(.x) replace_missing(x = .x,                                      method = \"linear\", ## linear interpolation                                      na.rm = FALSE, ## to preserve the length of the vector                                      maxgap = Inf) ## interpolate across gaps of any length         ),     )  plot(data_cleaned)"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"downsample-data","dir":"Articles","previous_headings":"","what":"Downsample Data","title":"Processing Data with {mNIRS}","text":"Say interested phenomena occurring time scale 5-minutes, NIRS data recorded 50 Hz, something like power data recorded 1 Hz. may easier synchronise data faster work fewer samples -sample NIRS data also 1 Hz. data: function works dataframe; take dataframe (data), apply processing step data channels, return processed dataframe. sample_column: dataframe already mNIRS.data metadata, time sample column detected automatically. Otherwise, can define overwrite explicitly. sample_rate: dataframe already mNIRS.data metadata, sample_rate detected automatically. Otherwise, can define overwrite explicitly. downsample_rate: Specify output sample rate want covert , number samples per second (Hz). value lower input sample_rate, else won’t anything. downsample_time: Alternatively, can specify output number seconds per sample produce result. example dataset already relatively low sample rate, let’s just see looks like reason wanted -sample 0.1 Hz (1 sample every 10 sec).  data channels certainly look smoother. kind like taken 10-second moving average data, lost information decreasing number samples. dataframe now 121 rows, compared original 2203 rows.","code":"data_downsampled <- data_cleaned |>      downsample_data(sample_column = NULL, ## will be automatically read from metadata                     sample_rate = NULL, ## will be automatically read from metadata                     downsample_time = 10) ## equal to `downsample_rate = 0.1` #> ℹ Sample rate = 2 Hz. Output is downsampled at 0.1 Hz.  data_downsampled #> # A tibble: 121 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1     0     1      54.1       66.7 #>  2    10     1      55.1       64.5 #>  3    20     1      55.8       65.4 #>  4    30     1      55.7       65.1 #>  5    40     1      55.5       62.8 #>  6    50     1      55.7       64.4 #>  7    60     1      55.3       66.2 #>  8    70     1      56.1       66.7 #>  9    80     1      56.8       66.4 #> 10    90     1      56.6       68.5 #> # ℹ 111 more rows  plot(data_downsampled)"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"downsample_data-options","dir":"Articles","previous_headings":"","what":"downsample_data() options","title":"Processing Data with {mNIRS}","text":"data: function works dataframe; take dataframe (data), apply processing step data channels, return processed dataframe. sample_column: dataframe already mNIRS.data metadata, time sample column detected automatically. Otherwise, can define overwrite explicitly. sample_rate: dataframe already mNIRS.data metadata, sample_rate detected automatically. Otherwise, can define overwrite explicitly. downsample_rate: Specify output sample rate want covert , number samples per second (Hz). value lower input sample_rate, else won’t anything. downsample_time: Alternatively, can specify output number seconds per sample produce result. example dataset already relatively low sample rate, let’s just see looks like reason wanted -sample 0.1 Hz (1 sample every 10 sec).  data channels certainly look smoother. kind like taken 10-second moving average data, lost information decreasing number samples. dataframe now 121 rows, compared original 2203 rows.","code":"data_downsampled <- data_cleaned |>      downsample_data(sample_column = NULL, ## will be automatically read from metadata                     sample_rate = NULL, ## will be automatically read from metadata                     downsample_time = 10) ## equal to `downsample_rate = 0.1` #> ℹ Sample rate = 2 Hz. Output is downsampled at 0.1 Hz.  data_downsampled #> # A tibble: 121 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1     0     1      54.1       66.7 #>  2    10     1      55.1       64.5 #>  3    20     1      55.8       65.4 #>  4    30     1      55.7       65.1 #>  5    40     1      55.5       62.8 #>  6    50     1      55.7       64.4 #>  7    60     1      55.3       66.2 #>  8    70     1      56.1       66.7 #>  9    80     1      56.8       66.4 #> 10    90     1      56.6       68.5 #> # ℹ 111 more rows  plot(data_downsampled)"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"digital-filtering","dir":"Articles","previous_headings":"","what":"Digital Filtering","title":"Processing Data with {mNIRS}","text":"want precise control improve signal--noise ratio dataset without losing information, apply digital filtering smooth data. digital filtering methods available. option best depend large part sample rate data frequency phenomena observed. Choosing filter parameters important processing step improve signal--noise ratio enhance subsequent interpretations. -filtering data can introduce data artefacts can influence signal analysis just much original noisy signal. perfectly valid choose digital filter empirically testing iterative filter parameters signal phenomena interest optimised signal--noise ratio minimal data artefacts. process choosing digital filter topic another vignette <currently development>. x: function works vector data; takes single data channel (x), applies processing channel, returns vector processed channel data. method = \"smooth-spline\": non-parametric smoothing spline often quite good first pass filter first examining data. can often good enough longer time-scale phenomena, 5-minute exercise interval, intervention gradual response curve. faster occurring repeated (square-wave) responses, smoothing-spline may appropriate. method = \"butterworth\": Butterworth low-pass digital filter probably common method used mNIRS research (whether appropriately, ). certain applications, identifying signal known frequency, cycling/running cadence heart rate, pass-band different filter type may better suited. method = \"moving-average\": simplest smoothing method simple moving average applied specified number samples. Commonly, might 5- 15-second centred moving average filter. Let’s try Butterworth low-pass filter, ’ll specify empirically chosen filter parameters. See ?filter_data details filtering methods respective parameters.","code":"data_filtered <- data_cleaned |>      mutate(         across(any_of(nirs_columns),                \\(.x) filter_data(x = .x,                                  method = \"butterworth\",                                  type = \"low\",                                  n = 2, ## see ?filter_data for details on filter parameters                                  W = 0.02)         )     )  ## we will add the non-filtered data back to the plot to compare plot(data_filtered) +     geom_line(data = data_cleaned,                aes(y = smo2_left, colour = \"smo2_left\"), alpha = 0.4) +     geom_line(data = data_cleaned,                aes(y = smo2_right, colour = \"smo2_right\"), alpha = 0.4)"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"choosing-a-digital-filter","dir":"Articles","previous_headings":"","what":"Choosing a digital filter","title":"Processing Data with {mNIRS}","text":"digital filtering methods available. option best depend large part sample rate data frequency phenomena observed. Choosing filter parameters important processing step improve signal--noise ratio enhance subsequent interpretations. -filtering data can introduce data artefacts can influence signal analysis just much original noisy signal. perfectly valid choose digital filter empirically testing iterative filter parameters signal phenomena interest optimised signal--noise ratio minimal data artefacts. process choosing digital filter topic another vignette <currently development>.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"filter_data-methods","dir":"Articles","previous_headings":"","what":"filter_data() methods","title":"Processing Data with {mNIRS}","text":"x: function works vector data; takes single data channel (x), applies processing channel, returns vector processed channel data. method = \"smooth-spline\": non-parametric smoothing spline often quite good first pass filter first examining data. can often good enough longer time-scale phenomena, 5-minute exercise interval, intervention gradual response curve. faster occurring repeated (square-wave) responses, smoothing-spline may appropriate. method = \"butterworth\": Butterworth low-pass digital filter probably common method used mNIRS research (whether appropriately, ). certain applications, identifying signal known frequency, cycling/running cadence heart rate, pass-band different filter type may better suited. method = \"moving-average\": simplest smoothing method simple moving average applied specified number samples. Commonly, might 5- 15-second centred moving average filter.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"smoothing-spline","dir":"Articles","previous_headings":"","what":"Smoothing-spline","title":"Processing Data with {mNIRS}","text":"method = \"smooth-spline\": non-parametric smoothing spline often quite good first pass filter first examining data. can often good enough longer time-scale phenomena, 5-minute exercise interval, intervention gradual response curve. faster occurring repeated (square-wave) responses, smoothing-spline may appropriate.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"butterworth-digital-filter","dir":"Articles","previous_headings":"","what":"Butterworth digital filter","title":"Processing Data with {mNIRS}","text":"method = \"butterworth\": Butterworth low-pass digital filter probably common method used mNIRS research (whether appropriately, ). certain applications, identifying signal known frequency, cycling/running cadence heart rate, pass-band different filter type may better suited.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"moving-average","dir":"Articles","previous_headings":"","what":"Moving average","title":"Processing Data with {mNIRS}","text":"method = \"moving-average\": simplest smoothing method simple moving average applied specified number samples. Commonly, might 5- 15-second centred moving average filter.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"apply-the-filter","dir":"Articles","previous_headings":"","what":"Apply the filter","title":"Processing Data with {mNIRS}","text":"Let’s try Butterworth low-pass filter, ’ll specify empirically chosen filter parameters. See ?filter_data details filtering methods respective parameters.","code":"data_filtered <- data_cleaned |>      mutate(         across(any_of(nirs_columns),                \\(.x) filter_data(x = .x,                                  method = \"butterworth\",                                  type = \"low\",                                  n = 2, ## see ?filter_data for details on filter parameters                                  W = 0.02)         )     )  ## we will add the non-filtered data back to the plot to compare plot(data_filtered) +     geom_line(data = data_cleaned,                aes(y = smo2_left, colour = \"smo2_left\"), alpha = 0.4) +     geom_line(data = data_cleaned,                aes(y = smo2_right, colour = \"smo2_right\"), alpha = 0.4)"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"shift-and-rescale-data","dir":"Articles","previous_headings":"","what":"Shift and Rescale Data","title":"Processing Data with {mNIRS}","text":"may need adjust data normalise NIRS signal values across channels, individuals trials, etc. example, may want set mean baseline value zero NIRS signals. may want compare signal kinetics (rate change time course response) rescaling relative dynamic range. functions allow us either shift values preserve dynamic range (delta amplitude minimum maximum values) NIRS channels, rescale data new dynamic range. can multiple NIRS channels either modify preserve relative scaling channels. may want shift data values preserving absolute dynamic range. See ?shift_data details. data: function works dataframe; take dataframe (data), apply processing step data channels, return processed dataframe. nirs_columns: list specifying want NIRS data channels grouped, preserve within-group relative scaling. Listing channel separately (e.g. list(\"\", \"B\", \"C\")) shift channel independently. relative scaling channels lost. Grouping channels (e.g. list(c(\"\", \"B\"), c(\"C\"))) shift group channels together. relative scaling channels preserved within group, lost across groups. dataframe already mNIRS.data metadata, NIRS data channels detected automatically processed grouped globally together. shift_to: NIRS value channels shifted. position: Specifies want shift data; either shifting “minimum”, “maximum”, “first” sample(s) value specified . mean_samples: Specifies many samples want average across shifting new value specified . default mean_samples = 1 shift single value. shift_by: alternate way specify, wanted shift data column , say 10 units. 2-minute baseline dataset, maybe want shift NIRS signals mean value 2-min baseline equal zero.  Now interpretation may change; assuming baseline represents starting condition, smo2_left signal deoxygenate far smo2_right signal. may want rescale data new dynamic range. See ?rescale_data details. data: function works dataframe; take dataframe (data), apply processing step data channels, return processed dataframe. nirs_columns: list specifying want NIRS data channels grouped, preserve within-group relative scaling (see Shift Data ). rescale_range: Specifies new dynamic range, form c(minimum, maximum). example, interested comparing ‘functional range’ NIRS signal, may want set 0-100%.  , interpretation may smo2_left appears deoxygenate slower ’s fullest extent incremental exercise, reoxygenate faster compared smo2_right. wanted shift NIRS signals mean 120-sec baselines equal, rescale dynamic range signals grouped, highest lowest values 0 100?  Now interpretation might assuming starting baseline condition tissues, smo2_left preserves greater relative oxygenation exercise immediate recovery compared smo2_right.","code":"data_shifted <- data_filtered |>      ## convert `nirs_columns` to separate list items to shift each column separately     shift_data(nirs_columns = as.list(nirs_columns),                shift_to = 0,                position = \"first\",                mean_samples = 120 * sample_rate) ## shift the mean first 120 sec equal to zero  plot(data_shifted) +     geom_hline(yintercept = 0, linetype = \"dotted\") data_rescaled <- data_filtered |>      ## convert `nirs_columns` vector to separate list items to shift each column separately     rescale_data(nirs_columns = as.list(nirs_columns),                   rescale_range = c(0, 100)) ## rescale to a 0-100% functional exercise range  plot(data_rescaled) +     geom_hline(yintercept = c(0, 100), linetype = \"dotted\") data_rescaled <- data_filtered |>       ## the lowest single value for each NIRS channel will be shifted to zero     shift_data(nirs_columns = as.list(nirs_columns),                shift_to = 0,                position = \"first\",                mean_samples = 120 * sample_rate) |>      ## Then both channels will be grouped and the maximum value of the two scaled to 100%     rescale_data(nirs_columns = list(nirs_columns),                   rescale_range = c(0, 100))  plot(data_rescaled) +     geom_hline(yintercept = c(0, 100), linetype = \"dotted\")"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"shift_data-options","dir":"Articles","previous_headings":"","what":"shift_data() options","title":"Processing Data with {mNIRS}","text":"may want shift data values preserving absolute dynamic range. See ?shift_data details. data: function works dataframe; take dataframe (data), apply processing step data channels, return processed dataframe. nirs_columns: list specifying want NIRS data channels grouped, preserve within-group relative scaling. Listing channel separately (e.g. list(\"\", \"B\", \"C\")) shift channel independently. relative scaling channels lost. Grouping channels (e.g. list(c(\"\", \"B\"), c(\"C\"))) shift group channels together. relative scaling channels preserved within group, lost across groups. dataframe already mNIRS.data metadata, NIRS data channels detected automatically processed grouped globally together. shift_to: NIRS value channels shifted. position: Specifies want shift data; either shifting “minimum”, “maximum”, “first” sample(s) value specified . mean_samples: Specifies many samples want average across shifting new value specified . default mean_samples = 1 shift single value. shift_by: alternate way specify, wanted shift data column , say 10 units. 2-minute baseline dataset, maybe want shift NIRS signals mean value 2-min baseline equal zero.  Now interpretation may change; assuming baseline represents starting condition, smo2_left signal deoxygenate far smo2_right signal.","code":"data_shifted <- data_filtered |>      ## convert `nirs_columns` to separate list items to shift each column separately     shift_data(nirs_columns = as.list(nirs_columns),                shift_to = 0,                position = \"first\",                mean_samples = 120 * sample_rate) ## shift the mean first 120 sec equal to zero  plot(data_shifted) +     geom_hline(yintercept = 0, linetype = \"dotted\")"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"rescale_data-options","dir":"Articles","previous_headings":"","what":"rescale_data() options","title":"Processing Data with {mNIRS}","text":"may want rescale data new dynamic range. See ?rescale_data details. data: function works dataframe; take dataframe (data), apply processing step data channels, return processed dataframe. nirs_columns: list specifying want NIRS data channels grouped, preserve within-group relative scaling (see Shift Data ). rescale_range: Specifies new dynamic range, form c(minimum, maximum). example, interested comparing ‘functional range’ NIRS signal, may want set 0-100%.  , interpretation may smo2_left appears deoxygenate slower ’s fullest extent incremental exercise, reoxygenate faster compared smo2_right.","code":"data_rescaled <- data_filtered |>      ## convert `nirs_columns` vector to separate list items to shift each column separately     rescale_data(nirs_columns = as.list(nirs_columns),                   rescale_range = c(0, 100)) ## rescale to a 0-100% functional exercise range  plot(data_rescaled) +     geom_hline(yintercept = c(0, 100), linetype = \"dotted\")"},{"path":"https://jemarnold.github.io/mNIRS.dev/articles/processing-mNIRS-data.html","id":"combined-shift-and-rescale","dir":"Articles","previous_headings":"","what":"Combined shift and rescale","title":"Processing Data with {mNIRS}","text":"wanted shift NIRS signals mean 120-sec baselines equal, rescale dynamic range signals grouped, highest lowest values 0 100?  Now interpretation might assuming starting baseline condition tissues, smo2_left preserves greater relative oxygenation exercise immediate recovery compared smo2_right.","code":"data_rescaled <- data_filtered |>       ## the lowest single value for each NIRS channel will be shifted to zero     shift_data(nirs_columns = as.list(nirs_columns),                shift_to = 0,                position = \"first\",                mean_samples = 120 * sample_rate) |>      ## Then both channels will be grouped and the maximum value of the two scaled to 100%     rescale_data(nirs_columns = list(nirs_columns),                   rescale_range = c(0, 100))  plot(data_rescaled) +     geom_hline(yintercept = c(0, 100), linetype = \"dotted\")"},{"path":"https://jemarnold.github.io/mNIRS.dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jem Arnold. Author, maintainer.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Arnold J (2025). mNIRS: Muscle Near-Infrared Spectroscopy Processing & Analysis. R package version 0.0.0.9012, https://github.com/jemarnold/mNIRS.","code":"@Manual{,   title = {mNIRS: Muscle Near-Infrared Spectroscopy Processing & Analysis},   author = {Jem Arnold},   year = {2025},   note = {R package version 0.0.0.9012},   url = {https://github.com/jemarnold/mNIRS}, }"},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"mnirs","dir":"","previous_headings":"","what":"Muscle Near-Infrared Spectroscopy Processing & Analysis","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"mNIRS package allow importing, processing, analysing data muscle near-infrared spectroscopy (mNIRS) devices.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"can install development version mNIRS GitHub :","code":"# install.packages(\"remotes\") devtools::install_github(\"jemarnold/mNIRS\")"},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"…","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"online-app","dir":"","previous_headings":"","what":"Online App","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"basic implementation package hosted https://jem-arnold.shinyapps.io/mNIRS-app/ can used mNIRS data importing cleaning.","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"read-data-from-file","dir":"","previous_headings":"Usage","what":"Read data from file","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"","code":"library(dplyr, warn.conflicts = FALSE)  ## load for data wrangling library(ggplot2) ## load for plotting library(mNIRS)  ## {mNIRS} includes sample files from a few NIRS devices file_path <- system.file(\"extdata/moxy_ramp_example.xlsx\", package = \"mNIRS\")  ## rename columns in the format `new_name1 = \"file_column_name1\"` ## where \"file_column_name1\" should match the file column name exactly data_raw <- read_data(file_path,                       nirs_columns = c(smo2_left = \"SmO2 Live\",                                        smo2_right = \"SmO2 Live(2)\"),                       sample_column = c(time = \"hh:mm:ss\"),                       event_column = c(lap = \"Lap\"),                       sample_rate = 2,                       numeric_time = TRUE,                       keep_all = FALSE,                       verbose = FALSE)  data_raw #> # A tibble: 2,203 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1 1740.     1        54         68 #>  2 1740.     1        54         68 #>  3 1741.     1        54         68 #>  4 1742.     1        54         66 #>  5 1742.     1        54         66 #>  6 1743.     1        54         66 #>  7 1743.     1        54         66 #>  8 1744.     1        57         67 #>  9 1744.     1        57         67 #> 10 1745.     1        57         67 #> # ℹ 2,193 more rows  plot(data_raw)"},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"replace-outliers-invalid-values-and-missing-values","dir":"","previous_headings":"Usage","what":"Replace outliers, invalid values, and missing Values","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"","code":"## metadata are stored in dataframe attributes nirs_columns <- attributes(data_raw)$nirs_columns sample_rate <- attributes(data_raw)$sample_rate  data_cleaned <- data_raw |>      mutate(         time = time - first(time), ## correct time column to start at zero         across(any_of(nirs_columns),                 \\(.x) replace_invalid(x = .x,                                      values = c(0, 100),                                      width = 20 * sample_rate,                                      return = \"NA\")         ),         across(any_of(nirs_columns),                 \\(.x) replace_outliers(x = .x,                                       width = 20 * sample_rate, ## 20 sec median window                                       t0 = 3,                                       na.rm = TRUE,                                       return = \"median\")         ),         across(any_of(nirs_columns),                 \\(.x) replace_missing(x = .x,                                      method = \"linear\",                                      na.rm = FALSE,                                      maxgap = Inf)         ),     )  data_cleaned #> # A tibble: 2,203 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1 0         1        54         68 #>  2 0.400     1        54         68 #>  3 0.960     1        54         68 #>  4 1.51      1        54         66 #>  5 2.06      1        54         66 #>  6 2.61      1        54         66 #>  7 3.16      1        54         66 #>  8 3.71      1        57         67 #>  9 4.26      1        57         67 #> 10 4.81      1        57         67 #> # ℹ 2,193 more rows  plot(data_cleaned)"},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"resample-data","dir":"","previous_headings":"Usage","what":"Resample data","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"","code":"data_resampled <- data_cleaned |>      downsample_data(sample_column = NULL, ## will be automatically read from metadata                     sample_rate = NULL, ## will be automatically read from metadata                     downsample_time = 10) ## equal to `downsample_rate = 0.1` #> ℹ Sample rate = 2 Hz. Output is downsampled at 0.1 Hz.  data_resampled #> # A tibble: 121 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1     0     1      54.1       66.7 #>  2    10     1      55.1       64.5 #>  3    20     1      55.8       65.4 #>  4    30     1      55.7       65.1 #>  5    40     1      55.5       62.8 #>  6    50     1      55.7       64.4 #>  7    60     1      55.3       66.2 #>  8    70     1      56.1       66.7 #>  9    80     1      56.8       66.4 #> 10    90     1      56.6       68.5 #> # ℹ 111 more rows  plot(data_resampled)"},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"filter-smooth-data","dir":"","previous_headings":"Usage","what":"Filter (smooth) data","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"","code":"data_filtered <- data_cleaned |>      mutate(         across(any_of(nirs_columns),                \\(.x) filter_data(x = .x,                                  method = \"butterworth\",                                  type = \"low\",                                  n = 2, ## see ?filter_data for details on filter parameters                                  W = 0.02)         )     )  data_filtered #> # A tibble: 2,203 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1 0         1      54.5       66.3 #>  2 0.400     1      54.5       66.3 #>  3 0.960     1      54.5       66.3 #>  4 1.51      1      54.5       66.3 #>  5 2.06      1      54.5       66.2 #>  6 2.61      1      54.5       66.2 #>  7 3.16      1      54.5       66.2 #>  8 3.71      1      54.5       66.2 #>  9 4.26      1      54.5       66.2 #> 10 4.81      1      54.5       66.2 #> # ℹ 2,193 more rows  plot(data_filtered)"},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"shift-and-rescale-data","dir":"","previous_headings":"Usage","what":"Shift and rescale data","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"","code":"data_shifted <- data_filtered |>      ## convert `nirs_columns` to separate list items to shift each column separately     shift_data(nirs_columns = as.list(nirs_columns),                shift_to = 0,                position = \"first\",                mean_samples = 120 * sample_rate) ## shift the mean first 120 sec equal to zero  data_shifted #> # A tibble: 2,203 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1 0         1     -1.17      0.835 #>  2 0.400     1     -1.17      0.832 #>  3 0.960     1     -1.17      0.827 #>  4 1.51      1     -1.17      0.819 #>  5 2.06      1     -1.16      0.808 #>  6 2.61      1     -1.16      0.795 #>  7 3.16      1     -1.15      0.779 #>  8 3.71      1     -1.14      0.762 #>  9 4.26      1     -1.13      0.741 #> 10 4.81      1     -1.12      0.719 #> # ℹ 2,193 more rows  plot(data_shifted) data_rescaled <- data_filtered |>      ## convert `nirs_columns` vector to separate list items to shift each column separately     rescale_data(nirs_columns = as.list(nirs_columns),                   rescale_range = c(0, 100)) ## rescale to a 0-100% functional exercise range  data_rescaled #> # A tibble: 2,203 × 4 #>     time   lap smo2_left smo2_right #>    <dbl> <dbl>     <dbl>      <dbl> #>  1 0         1      65.5       76.3 #>  2 0.400     1      65.5       76.3 #>  3 0.960     1      65.5       76.3 #>  4 1.51      1      65.5       76.3 #>  5 2.06      1      65.5       76.3 #>  6 2.61      1      65.6       76.3 #>  7 3.16      1      65.6       76.3 #>  8 3.71      1      65.6       76.2 #>  9 4.26      1      65.6       76.2 #> 10 4.81      1      65.6       76.2 #> # ℹ 2,193 more rows  plot(data_rescaled)"},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"process-kinetics","dir":"","previous_headings":"Usage","what":"Process kinetics","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"<development>","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/index.html","id":"mnirs-device-compatibility","dir":"","previous_headings":"","what":"mNIRS Device Compatibility","title":"Muscle Near-Infrared Spectroscopy Processing & Analysis","text":"package designed recognise mNIRS data exported .xlsx, .xls, .csv files. flexible use many different mNIRS devices, compatibility improve continued development. package tested successfully following mNIRS devices: Artinis Portamon Oxymon Moxy 5 3 Train.Red FYER Plus package tested successfully mNIRS data exported following devices apps: Artinis Oxysoft software (.csv .xlsx) Moxy onboard export (.csv) PerfPro software (.xlsx) Train.Red app (.csv) VO2 Master Manager app (.xlsx)","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/SSmonoexp.html","id":null,"dir":"Reference","previous_headings":"","what":"Initiate Self-Starting nls Monoexponential Model — SSmonoexp","title":"Initiate Self-Starting nls Monoexponential Model — SSmonoexp","text":"monoexp_init(): Returns initial values parameters selfStart model. SSmonoexp(): Creates initial coefficient estimates selfStart model four-parameter monoexponential() function. parameters , B, TD, tau.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/SSmonoexp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initiate Self-Starting nls Monoexponential Model — SSmonoexp","text":"","code":"monoexp_init(mCall, data, LHS, ...)  SSmonoexp(x, A, B, TD, tau)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/SSmonoexp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initiate Self-Starting nls Monoexponential Model — SSmonoexp","text":"mCall matched call function model. data data frame interpret variables mCall. LHS expression left-hand side model formula call nls. ... Additional arguments. x numeric predictor variable evaluate response variable y. numeric parameter starting (baseline) value response variable y. B numeric parameter ending (asymptote) value response variable y. TD numeric parameter time delay exponential inflection curve, units predictor variable x. tau numeric parameter time constant tau (𝜏) exponential curve, units predictor variable x. tau equal reciprocal k (tau = 1/k), k rate constant function.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/SSmonoexp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initiate Self-Starting nls Monoexponential Model — SSmonoexp","text":"monoexp_init(): Initial starting estimates parameters model called SSmonoexp(). SSmonoexp(): numeric vector response variabel y length predictor variable x. Returned expression ifelse(x <= TD, , + (B - ) * (1 - exp((TD - x) / tau))).","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/SSmonoexp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initiate Self-Starting nls Monoexponential Model — SSmonoexp","text":"","code":"set.seed(13) x <- seq(0, 60, by = 2) A <- 10; B <- 100; TD <- 15; tau <- 8 y <- monoexponential(x, A, B, TD, tau) + rnorm(length(x), 0, 3) data <- data.frame(x, y)  model <- nls(y ~ SSmonoexp(x, A, B, TD, tau), data = data) model #> Nonlinear regression model #>   model: y ~ SSmonoexp(x, A, B, TD, tau) #>    data: data #>      A      B     TD    tau  #> 11.973 99.313 15.229  7.976  #>  residual sum-of-squares: 232.9 #>  #> Number of iterations to convergence: 5  #> Achieved convergence tolerance: 5.452e-06  if (FALSE) { # \\dontrun{ plot(x, y) lines(x, y) points(x, y) lines(x, fitted(model), col = \"red\") } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/create_mNIRS_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an mNIRS Dataframe with Metadata — create_mNIRS_data","title":"Create an mNIRS Dataframe with Metadata — create_mNIRS_data","text":"Manually add class \"mNIRS.data\" metadata existing dataframe.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/create_mNIRS_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an mNIRS Dataframe with Metadata — create_mNIRS_data","text":"","code":"create_mNIRS_data(data, metadata)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/create_mNIRS_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an mNIRS Dataframe with Metadata — create_mNIRS_data","text":"data dataframe. metadata Metadata passed along dataframe. nirs_device nirs_columns sample_column event_column sample_rate event_sample_list fit_window display_window end_kinetics_window","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/create_mNIRS_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an mNIRS Dataframe with Metadata — create_mNIRS_data","text":"tibble class mNIRS.data metadata available attributes().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/create_mNIRS_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an mNIRS Dataframe with Metadata — create_mNIRS_data","text":"","code":"## currently implemented metadata metadata <- list(nirs_device = NULL,                  nirs_columns = NULL,                  sample_column = NULL,                  event_column = NULL,                  sample_rate = NULL,                  event_sample_list = NULL,                  fit_window = NULL,                  display_window = NULL,                  end_kinetics_window = NULL)  df <- data.frame(A = 1:3,                  B = seq(10, 30, 10),                  C = seq(11, 33, 11)) attributes(df) #> $names #> [1] \"A\" \"B\" \"C\" #>  #> $class #> [1] \"data.frame\" #>  #> $row.names #> [1] 1 2 3 #>   nirs_data <- create_mNIRS_data(     df,     metadata = list(nirs_columns = c(\"B\", \"C\"),                     sample_column = \"A\",                     sample_rate = 1) ) attributes(nirs_data) #> $class #> [1] \"mNIRS.data\" \"tbl_df\"     \"tbl\"        \"data.frame\" #>  #> $row.names #> [1] 1 2 3 #>  #> $names #> [1] \"A\" \"B\" \"C\" #>  #> $nirs_columns #> [1] \"B\" \"C\" #>  #> $sample_column #> [1] \"A\" #>  #> $sample_rate #> [1] 1 #>"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/downsample_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Downsample Data — downsample_data","title":"Downsample Data — downsample_data","text":"Condense number samples dataframe using time-weighted averaging.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/downsample_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Downsample Data — downsample_data","text":"","code":"downsample_data(   data,   sample_column = NULL,   sample_rate = NULL,   downsample_rate = NULL,   downsample_time = NULL,   verbose = TRUE )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/downsample_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Downsample Data — downsample_data","text":"data dataframe. sample_column optional character scalar indicating name time sample data column. Must match exactly. sample_rate optional numeric scalar sample rate Hz. downsample_rate optional numeric scalar indicating desired output sample rate (Hz) convert dataframe. downsample_time optional numeric scalar indicating desired sample time (seconds) convert dataframe. verbose logical. TRUE (default) return warnings messages can used data error checking. FALSE silence messages. Errors always returned.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/downsample_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Downsample Data — downsample_data","text":"tibble class mNIRS.data metadata available attributes().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/downsample_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Downsample Data — downsample_data","text":"sample_column sample_rate taken metadata mNIRS dataframe, defined explicitly. present metadata, sample_column must defined explicitly. sample_rate estimated based mean difference values sample_column. sample_column contains integer sample numbers, sample_rate incorrectly estimated  1 Hz, defined explicitly. TODO include upsample interpolation?","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filter_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter Data — filter_data","title":"Filter Data — filter_data","text":"Apply signal filtering vector data either: 1. cubic smoothing spline. 2. Butterworth digital filter. 3. simple moving average.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filter_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter Data — filter_data","text":"","code":"filter_data(   x,   method = c(\"smooth-spline\", \"butterworth\", \"moving-average\"),   type = c(\"low\", \"high\", \"stop\", \"pass\"),   spar = NULL,   n = 1,   W,   critical_frequency,   sample_rate,   width,   verbose )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filter_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter Data — filter_data","text":"x numeric vector. method Indicates filter data (see Details). \"smooth-spline\" fits cubic smoothing spline. \"butterworth\" uses centred Butterworth digital filter. type defined (see Details). \"moving-average\" uses centred moving average filter. type Specify filter type. relevant method = \"butterworth\" (see Details). \"low\" low-pass filter (default). \"high\" high-pass filter. \"stop\" stop-band (band-reject) filter. \"pass\" pass-band filter. spar numeric scalar defining smoothing parameter method = \"smooth-spline\". n integer scalar defining order Butterworth filter method = \"butterworth\". W numeric scalar two-element vector defining fractional critical frequency(ies) Butterworth filter method = \"butterworth\". critical_frequency numeric scalar two-element vector defining critical frequency(ies) Butterworth filter method = \"butterworth\". sample_rate numeric scalar sample rate Hz method = \"butterworth\". width numeric scalar defining window length samples method = \"moving-average\". verbose logical. TRUE (default) return warnings messages can used troubleshooting. FALSE silence messages. Errors always returned.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filter_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter Data — filter_data","text":"numeric vector filtered data.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filter_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Filter Data — filter_data","text":"method = \"smooth-spline\" applies non-parametric cubic smoothing spline stats::smooth.spline(). Smoothing defined parameter spar, can left blank automatically determined via penalised log liklihood. usually works well smoothing responses occurring order minutes longer. spar can defined explicitly, typically (necessarily) range spar = [0, 1]. method = \"butterworth\" applies centred (two-pass symmetrical) Butterworth digital filter signal::butter() signal::filtfilt(). filter order defined n, typically range n = [1, 10]. Higher filter orders tend better capture rapid changes amplitude, also cause distortion artefacts signal. General advice use lowest order sufficiently captures rapid step-changes data. Filter type defines desired signal frequencies either passed rejected output signal. Low-pass high-pass filters allow frequencies lower higher critical frequency W passed output signal, respectively. Stop-band defines critical range frequencies rejected output signal. Pass-band defines critical range frequencies passed output signal. critical (cutoff) frequency defined W, numeric scalar low-pass high-pass filters, two-element vector c(low, high) defining lower upper bands stop-band pass-band filters. W represents desired fractional critical frequency range W = [0, 1], 1 Nyquist frequency, .e., half sample rate data Hz. Alternatively, critical frequency can defined critical_frequency sample_rate together. critical_frequency represents desired critical frequency Hz, sample_rate sample rate recorded data Hz. W = critical_frequency / (sample_rate/2). Defining critical_frequency sample_rate explicitly overwrite W. method = \"moving-average\" applies centred (two-way symmetrical) moving average filter zoo::rollapply(). moving-average calculated window width width defining number samples [- floor(width/2), + floor(width/2)]. partial moving- average calculated edges existing data.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filter_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter Data — filter_data","text":"","code":"set.seed(13) n <- 500 x <- seq(0, 2*pi, len = n) y_clean <- 2*sin(x) noise <- rnorm(n, mean = 0, sd = 0.5) y <- y_clean + noise  y.spline <- filter_data(y, method = \"smooth-spline\") #> ℹ `smooth.spline()` `spar` set to 0.861829231501579 y.LP <- filter_data(y, method = \"butterworth\", n = 2, W = 0.05) y.MA <- filter_data(y, method = \"moving-average\", width = 30)  if (FALSE) { # \\dontrun{ plot(x, y) lines(x, y.spline, lwd = 2, col = \"blue\") lines(x, y.LP, lwd = 2, col = \"red\") lines(x, y.MA, lwd = 2, col = \"green4\") } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filtfilt_edges.html","id":null,"dir":"Reference","previous_headings":"","what":"Butterworth Filter with Better Edge Detection — filtfilt_edges","title":"Butterworth Filter with Better Edge Detection — filtfilt_edges","text":"Apply Butterworth digital filter vector data signal::butter() signal::filtfilt() handles 'edges' better start end data.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filtfilt_edges.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Butterworth Filter with Better Edge Detection — filtfilt_edges","text":"","code":"filtfilt_edges(   x,   n = 1,   W,   type = c(\"low\", \"high\", \"stop\", \"pass\"),   edges = c(\"rev\", \"rep1\", \"none\") )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filtfilt_edges.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Butterworth Filter with Better Edge Detection — filtfilt_edges","text":"x numeric vector. n integer scalar defining filter order number. W numeric scalar two-element vector defining fractional critical frequency filter (see Details). type Digital filter type (see Details). \"low\" low-pass filter (default). \"high\" high-pass filter. \"stop\" stop-band (band-reject) filter. \"pass\" pass-band filter. edges Indicates pad x. \"rev\" pad x preceding 10% data reverse sequence (default). \"rep1\" pad x last preceding value. \"none\" return default signal::filtfilt() output.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filtfilt_edges.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Butterworth Filter with Better Edge Detection — filtfilt_edges","text":"numeric vector length x.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filtfilt_edges.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Butterworth Filter with Better Edge Detection — filtfilt_edges","text":"Applies centred (two-pass symmetrical) Butterworth digital filter signal::butter() signal::filtfilt(). filter order defined n, integer scalar typically range n = [1, 10]. critical (cutoff) frequency defined W, numeric scalar low-pass high-pass filters, two-element vector c(low, high) defining lower upper bands stop-band pass-band filters. Low-pass high-pass filters allow frequencies lower higher critical frequency W passed output signal, respectively. Stop-band defines critical range frequencies rejected output signal. Pass-band defines critical range frequencies passed output signal.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/filtfilt_edges.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Butterworth Filter with Better Edge Detection — filtfilt_edges","text":"","code":"set.seed(13) sin <- sin(2 * pi * 1:150 / 50) * 20 + 40 noise <- rnorm(150, mean = 0, sd = 6) noisy_sin <- sin + noise filt_without_edge <- filtfilt_edges(x = noisy_sin, n = 2, W = 0.1, edges = \"none\") filt_with_edge <- filtfilt_edges(x = noisy_sin, n = 2, W = 0.1, edges = \"rep1\")  if (FALSE) { # \\dontrun{ plot(noisy_sin, type = \"l\") lines(filt_without_edge, col = \"red\", lwd = 4) lines(filt_with_edge, col = \"blue\", lwd = 4) } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mNIRS: Muscle Near-Infrared Spectroscopy Processing & Analysis — mNIRS-package","title":"mNIRS: Muscle Near-Infrared Spectroscopy Processing & Analysis — mNIRS-package","text":"Methods importing, processing, analysing data muscle near-infrared spectroscopy (mNIRS) devices.","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mNIRS: Muscle Near-Infrared Spectroscopy Processing & Analysis — mNIRS-package","text":"Maintainer: Jem Arnold jem.arnold@ubc.com (ORCID)","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS.kinetics-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for mNIRS.kinetics objects — mNIRS.kinetics-methods","title":"Methods for mNIRS.kinetics objects — mNIRS.kinetics-methods","text":"Generic methods defined objects returned process_kinetics().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS.kinetics-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for mNIRS.kinetics objects — mNIRS.kinetics-methods","text":"","code":"# S3 method for class 'mNIRS.kinetics' print(x, ...)  # S3 method for class 'mNIRS.kinetics' plot(x, ...)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS.kinetics-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for mNIRS.kinetics objects — mNIRS.kinetics-methods","text":"x Object class mNIRS.kinetics returned process_kinetics(). ... Additional arguments. plot_coefs plot_coefs = TRUE display kinetics coefficients top left plot. plot_diagnostics plot_diagnostics = TRUE display kinetics model diagnostic metrics bottom right plot. plot_residuals plot_diagnostics = TRUE display kinetics model residuals along bottom plot. Residual values correctly scaled zero dotted line","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS.kinetics-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for mNIRS.kinetics objects — mNIRS.kinetics-methods","text":"Return: print Returns model summary plot Returns ggplot2 object","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS_palette.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom mNIRS colour palette — mNIRS_palette","title":"Custom mNIRS colour palette — mNIRS_palette","text":"Custom mNIRS colour palette","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS_palette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom mNIRS colour palette — mNIRS_palette","text":"","code":"mNIRS_palette(n = NULL)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS_palette.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Custom mNIRS colour palette — mNIRS_palette","text":"n Number colours return, order.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS_palette.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Custom mNIRS colour palette — mNIRS_palette","text":"Named character vector hex colours.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/mNIRS_palette.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Custom mNIRS colour palette — mNIRS_palette","text":"","code":"if (FALSE) { # \\dontrun{ scales::show_col(mNIRS_palette()) } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/monoexponential.html","id":null,"dir":"Reference","previous_headings":"","what":"Monoexponential Function with 4 Parameters — monoexponential","title":"Monoexponential Function with 4 Parameters — monoexponential","text":"Calculate four-parameter monoexponential curve.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/monoexponential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Monoexponential Function with 4 Parameters — monoexponential","text":"","code":"monoexponential(x, A, B, TD, tau)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/monoexponential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Monoexponential Function with 4 Parameters — monoexponential","text":"x numeric predictor variable evaluate response variable y. numeric parameter starting (baseline) value response variable y. B numeric parameter ending (asymptote) value response variable y. TD numeric parameter time delay exponential inflection curve, units predictor variable x. tau numeric parameter time constant tau (𝜏) exponential curve, units predictor variable x. tau equal reciprocal k (tau = 1/k), k rate constant function.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/monoexponential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Monoexponential Function with 4 Parameters — monoexponential","text":"numeric vector response variabel y length predictor variable x.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/monoexponential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Monoexponential Function with 4 Parameters — monoexponential","text":"","code":"set.seed(13) x <- seq(0, 60, by = 2) A <- 10; B <- 100; TD <- 15; tau <- 8 y <- monoexponential(x, A, B, TD, tau) + rnorm(length(x), 0, 3) data <- data.frame(x, y)  model <- nls(y ~ SSmonoexp(x, A, B, TD, tau), data = data) model #> Nonlinear regression model #>   model: y ~ SSmonoexp(x, A, B, TD, tau) #>    data: data #>      A      B     TD    tau  #> 11.973 99.313 15.229  7.976  #>  residual sum-of-squares: 232.9 #>  #> Number of iterations to convergence: 5  #> Achieved convergence tolerance: 5.452e-06  if (FALSE) { # \\dontrun{ plot(x, y) lines(x, y) points(x, y) lines(x, fitted(model), col = \"red\") } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/peak_slope.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Peak Positive or Negative Slope — peak_slope","title":"Calculate Peak Positive or Negative Slope — peak_slope","text":"Computes peak directional linear regression slope upward downward trending response variable y, respectively using rolling_slope() within moving window.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/peak_slope.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Peak Positive or Negative Slope — peak_slope","text":"","code":"peak_slope(   y,   x = seq_along(y),   width,   align = c(\"center\", \"left\", \"right\"),   na.rm = FALSE )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/peak_slope.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Peak Positive or Negative Slope — peak_slope","text":"y numeric vector response variable. x numeric vector predictor variable, defaults using index x = seq_along(y). width numeric scalar defining window width units x rolling calculations. align Specifies window alignment width \"center\" (default), \"left\", \"right\". \"left\" forward looking, \"right\" backward looking window width current sample. na.rm logical indicating missing data handled. FALSE (default) perform rolling slopes complete case analysis return peak rolling slopes local y samples valid. TRUE return peak rolling slopes local target y sample valid.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/peak_slope.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Peak Positive or Negative Slope — peak_slope","text":"list class mNIRS.kinetics components L$...: x x position local peak slope. y y value predicted linear regression local peak slope. slope slope value units y/x. x_fitted range x values given width corresponding local peak slope. y_fitted range y values given width predicted linear regression, corresponding local peak slope.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/peak_slope.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Peak Positive or Negative Slope — peak_slope","text":"Uses least squares formula complete case analysis calculate local slopes within rolling window along x specified width units x. .e. x = 10 include samples within 10-second window time series data. direction y (upward downward) determine whether positive negative peak slope returned. Peak positive slope returned overall slope >= 0.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/peak_slope.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Peak Positive or Negative Slope — peak_slope","text":"","code":"y <- c(1, 3, 2, 5, 8, 7, 9, 12, 11, 14) peak_slope(y, width = 3) #> $x #> [1] 4 #>  #> $y #> [1] 5 #>  #> $slope #> [1] 3 #>  #> $x_fitted #> [1] 3 4 5 #>  #> $y_fitted #> [1] 2 5 8 #>   y <- c(14, 11, 12, 9, 7, 8, 5, 2, 3, 1) peak_slope(y, width = 3) #> $x #> [1] 1 #>  #> $y #> [1] 14 #>  #> $slope #> [1] -3 #>  #> $x_fitted #> [1] 1 2 #>  #> $y_fitted #> [1] 14 11 #>"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/plot.mNIRS.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot mNIRS.data objects — plot.mNIRS.data","title":"Plot mNIRS.data objects — plot.mNIRS.data","text":"Create simple plot objects returned create_mNIRS_data().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/plot.mNIRS.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot mNIRS.data objects — plot.mNIRS.data","text":"","code":"# S3 method for class 'mNIRS.data' plot(x, ...)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/plot.mNIRS.data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot mNIRS.data objects — plot.mNIRS.data","text":"x Object class mNIRS.data returned create_mNIRS_data() ... Additional arguments, na.omit = FALSE logical indicating whether missing data (NA) omitted (TRUE) better display disconnected lines, included (FALSE, default) better recognise data missing.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/plot.mNIRS.data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot mNIRS.data objects — plot.mNIRS.data","text":"ggplot2 object.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/prepare_kinetics_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare mNIRS Data for Kinetics Analysis — prepare_kinetics_data","title":"Prepare mNIRS Data for Kinetics Analysis — prepare_kinetics_data","text":"Processes list one dataframes class \"mNIRS.data\" representing distinct ensembled kinetics events analysis.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/prepare_kinetics_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare mNIRS Data for Kinetics Analysis — prepare_kinetics_data","text":"","code":"prepare_kinetics_data(   data,   event_sample = NULL,   event_label = NULL,   event_index = NULL,   fit_window = c(30, 180),   display_window = NULL,   group_events = list(\"distinct\", \"ensemble\"),   nirs_columns = NULL,   sample_column = NULL,   event_column = NULL,   sample_rate = NULL,   ... )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/prepare_kinetics_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare mNIRS Data for Kinetics Analysis — prepare_kinetics_data","text":"data dataframe class \"mNIRS.data\". event_sample optional numeric vector corresponding values sample_column indicating start kinetic events. .e., time value sample number. event_label optional character vector corresponding values event_column indicating start kinetics events. .e., event label \"end work\". event_index optional numeric vector indicating starting row indices kinetics events. .e., identify start kinetic events row number. fit_window two-element numeric vector form c(, ) units sample_column, defining window around kinetics events include model fitting process (default = c(30, 180)). display_window (currently implemented) optional two-element numeric vector form c(, ) units sample_column, defining window around kinetics events include display, model fitting. group_events Indicates kinetics events analysed. Typically either \"distinct\" (default) \"ensemble\", can manually specified (see Details). nirs_columns character vector indicating mNIRS data columns processed dataframe. Must match data column names exactly. Can taken metadata defined explicitly. sample_column character scalar indicating time sample data column. Must match data column names exactly. Can taken metadata defined explicitly. event_column optional character scalar indicating event lap data column. Must match data column names exactly. Can taken metadata defined explicitly. sample_rate numeric scalar sample rate Hz. taken metadata defined explicitly. ... Additional arguments.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/prepare_kinetics_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare mNIRS Data for Kinetics Analysis — prepare_kinetics_data","text":"list tibbles class mNIRS.data metadata available attributes().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/prepare_kinetics_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prepare mNIRS Data for Kinetics Analysis — prepare_kinetics_data","text":"display_window defines widest range data kinetics event passed dataframe, included modelling process. fit_window defines widest extent data kinetics event may included modelling process. group_events indicates kinetics events analysed, either separately, grouped ensemble averaged similar oxygen uptake kinetics. group_events = \"distinct\" prepare list unique dataframes kinetics event (default). group_events = \"ensemble\" prepare one dataframe ensemble-averaged data mNIRS kinetics events. group_events = list(c(1, 2), c(3, 4)) group kinetic events together sequence appearance, prepare list ensemble-averaged dataframes group. kinetic events detected data explicitly defined return distinct dataframe.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/process_kinetics.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Kinetics — process_kinetics","title":"Fit Kinetics — process_kinetics","text":"Perform parametric curve fitting non-parametric estimation mNIRS kinetics vector data.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/process_kinetics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Kinetics — process_kinetics","text":"","code":"# S3 method for class 'monoexponential' process_kinetics(   y,   x = NULL,   data = NULL,   x0 = 0,   window = 30,   method = c(\"monoexponential\", \"sigmoidal\", \"half_time\", \"peak_slope\"),   verbose = TRUE,   ... )  # S3 method for class 'sigmoidal' process_kinetics(   y,   x = NULL,   data = NULL,   x0 = 0,   window = 30,   method = c(\"monoexponential\", \"sigmoidal\", \"half_time\", \"peak_slope\"),   verbose = TRUE,   ... )  # S3 method for class 'half_time' process_kinetics(   y,   x = NULL,   data = NULL,   x0 = 0,   window = 30,   method = c(\"monoexponential\", \"sigmoidal\", \"half_time\", \"peak_slope\"),   verbose = TRUE,   ... )  # S3 method for class 'peak_slope' process_kinetics(   y,   x = NULL,   data = NULL,   x0 = 0,   window = 30,   method = c(\"monoexponential\", \"sigmoidal\", \"half_time\", \"peak_slope\"),   verbose = TRUE,   ... )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/process_kinetics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Kinetics — process_kinetics","text":"y numeric vector response variable, name variable within dataframe. x optional numeric vector predictor variable, name variable within dataframe. Defaults using index x = seq_along(y). data optional dataframe containing predictor response variables named x y. Names x y must quotations. x0 (Default = 0) numeric scalar indicating value predictor variable x representing start kinetics event. window (Default = 30) numeric scalar indicating local window units predictor variable x kinetics extreme (peak trough) value look subsequent greater extremes. kinetics model fit data first local extreme subsequent greater extremes within lesser either window limits data. method Indicates model evaluate kinetics event (see Details method parametrisation). method = \"monoexponential\" four-parameter monoexponential association function form: ifelse(x <= TD, , + (B - ) * (1 - exp((TD - x) / tau))). method = \"sigmoidal\" four-parameter generalised logistic (sigmoidal) function form: + (B - ) / (1 + exp((xmid - x) / scal)). method = \"half_time\" non-parametric estimate time recover half total reoxygenation amplitude. method = \"peak_slope\" non-parametric estimate time reach peak rolling linear regression slope within window defined width. verbose logical. TRUE (default) return warnings messages can used data error checking. FALSE silence messages. Errors always returned. ... Additional arguments. width numeric scalar defining window width (units predictor variable x) rolling slope calculations (used method = \"peak_slope\"). align = c(\"center\", \"left\", \"right\") Specifies window alignment width \"center\" (default), \"left\", \"right\". \"left\" forward looking, \"right\" backward looking window width current observation (used method = \"peak_slope\"). fixed parameters Parameters (coefficients) parametric models (\"monoexponential\" \"sigmoidal\") can defined priori fixed, exclude model fitting optimisation. e.g., = 10 define function SSmonoexp(x, = 10, B, TD, tau).","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/process_kinetics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Kinetics — process_kinetics","text":"list class mNIRS.kinetics components L$...: method kinetics method used. model model object. equation equation kinetics model used. data dataframe original fitted model data. fitted vector fitted values returned model. residuals vector residuals original fitted values returned model. x0 value predictor variable indicating start kinetics. coefs dataframe model coefficients, including manually fixed parameters. diagnostics dataframe model goodness--fit metrics (AIC, BIC, R2adj RMSE, MAE, MAPE). call model call.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/process_kinetics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit Kinetics — process_kinetics","text":"method %% c(\"monoexponential\", \"sigmoidal\") use nls() nonlinear (weighted) least-squares estimates. Model Parameterisation \"monoexponential\": four-parameter monoexponential association function form: ifelse(x <= TD, , + (B - ) * (1 - exp((TD - x) / tau))). : text B: text TD: text tau: text MRT: text \"sigmoidal\": four-parameter generalised logistic (sigmoidal) function form: + (B - ) / (1 + exp((xmid - x) / scal)). : text B: text xmid: text scal: text \"half_time\": non-parametric estimate time recover half total reoxygenation amplitude. : text B: text half_value: text \"peak_slope\": non-parametric estimate time reach peak rolling linear regression slope within window defined width. : text B: text x_fitted: text peak_slope: text","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/process_kinetics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Kinetics — process_kinetics","text":"","code":"set.seed(13) x1 <- seq(-10, 60, by = 2) A <- 10; B <- 100; TD <- 5; tau <- 12 y1 <- monoexponential(x1, A, B, TD, tau) + rnorm(length(x1), 0, 3)  ## monoexponential kinetics =============================== model <- process_kinetics(y1, x1, method = \"monoexponential\") model #>  #> Monoexponential (Association) Nonlinear nls() Regression #>   model:        y ~ SSmonoexp(x, A, B, TD, tau) #>   data:         data.frame(x = x, y = y) #>   equation:     y ~ A + (B - A) * (1 - exp((TD - x) / tau)) #>  #>   Model Coefficients: #>        A      B    TD    tau    MRT MRT_fitted #> 1 11.973 98.899 5.436 11.646 17.082     66.921 #>  #>   Model Diagnostics: #>       AIC     BIC R2adj  RMSE   MAE  MAPE #> 1 180.958 188.875 0.994 2.600 2.046 5.465 #>   if (FALSE) { # \\dontrun{ ## require(ggplot2) plot(model, plot_coefs = TRUE, plot_diagnostics = TRUE, plot_residuals = TRUE) } # }  ## sigmoidal kinetics =============================== model <- process_kinetics(y1, x1, method = \"sigmoidal\") model #>  #> Sigmoidal (Generalised Logistic) Nonlinear nls() Regression #>   model:        y ~ SSfpl(x, A, B, xmid, scal) #>   data:         data.frame(x = x, y = y) #>   equation:     y ~ A + (B - A) / (1 + exp((xmid - x) / scal)) #>  #>   Model Coefficients: #>       A      B  scal   xmid xmid_fitted #> 1 7.929 95.468 5.178 13.919      51.699 #>  #>   Model Diagnostics: #>       AIC     BIC R2adj  RMSE   MAE  MAPE #> 1 199.881 207.798 0.990 3.381 2.661 9.035 #>   if (FALSE) { # \\dontrun{ ## require(ggplot2) plot(model, plot_coefs = TRUE, plot_diagnostics = TRUE, plot_residuals = TRUE) } # }  ## half recovery time =============================== model <- process_kinetics(y1, x1, method = \"half_time\") model #>  #> Non-parametric Half Response Time #>   data:         data.frame(x = x, y = y) #>   equation:     half_x ~ interp_x(y = A + (B - A) / 2) #>  #>   Model Coefficients: #>        A       B half_x half_value #> 1 11.663 100.752 16.000     56.207 #>   if (FALSE) { # \\dontrun{ ## require(ggplot2) plot(model, plot_coefs = TRUE, plot_diagnostics = TRUE, plot_residuals = TRUE) } # }  ## peak slope =============================== model <- process_kinetics(y1, x1, method = \"peak_slope\", width = 10) model #>  #> Peak Linear Regression Rolling Slope #>   data:         data.frame(x = x, y = y) #>   equation:     peak_slope ~ max(rolling_slope(y ~ x, width = 10)) #>  #>   Model Coefficients: #>   peak_slope_x peak_slope_fitted peak_slope #> 1        8.000            33.223      5.110 #>   if (FALSE) { # \\dontrun{ ## require(ggplot2) plot(model, plot_coefs = TRUE, plot_diagnostics = TRUE, plot_residuals = TRUE) } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/read_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Read mNIRS Data From File — read_data","title":"Read mNIRS Data From File — read_data","text":"read files exported commercially available mNIRS devices return dataframe class \"mNIRS.data\" recorded data metadata.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/read_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read mNIRS Data From File — read_data","text":"","code":"read_data(   file_path,   nirs_columns,   sample_column = NULL,   event_column = NULL,   sample_rate = NULL,   numeric_time = TRUE,   keep_all = FALSE,   verbose = TRUE )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/read_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read mNIRS Data From File — read_data","text":"file_path file path including extension (either \".xlsx\", \".xls\", \".csv\") import. nirs_columns character vector indicating mNIRS data columns import file. Must match column names data file exactly. named character vector can used rename columns form: c(new_name = \"old_name\") (see Details). sample_column optional character scalar indicating time sample data column import file. Must match column names data file exactly. named character vector can used rename columns form: c(new_name = \"old_name\") (see Details). event_column optional character scalar indicating event lap data column import file. Must match column names data file exactly. named character vector can used rename columns form: c(new_name = \"original_name\") (see Details). sample_rate optional numeric scalar sample rate Hz. defined explicitly, estimated data (see Details). numeric_time logical. TRUE (default) convert date-time formatted sample_column numeric values seconds. FALSE return sample_column format original file. keep_all logical. FALSE (default) include explicitly specified data columns. TRUE include columns detected file. verbose logical. TRUE (default) return warnings messages can used troubleshooting. FALSE silence messages. Errors always returned.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/read_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read mNIRS Data From File — read_data","text":"tibble class \"mNIRS.data\" metadata available attributes().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/read_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read mNIRS Data From File — read_data","text":"Column names matched single row, anywhere data file, necessarily top row file. Columns can renamed format c(new_name = \"original_name\"), \"original_name\" match column names found file exactly. duplicate column names file, columns matched order appear. may want confirm correct columns assigned intended. sample_column specified, index column added row numbers. specified sample_column contains unequal sampling (.e., repeated values unordered samples) warning given suggesting user confirm file data manually. sample_column provided date-time format (e.g. hh:mm:ss), can converted back numeric values numeric_time = TRUE. case, values recalculated starting 0 first sample. sample_column typically represent time values seconds. However, NIRS devices export sample index. can converted time values sample_rate known. sample_rate required certain {mNIRS} functions work properly. defined explicitly, estimated based mean difference values sample_column. sample_column defined, sample_rate set 1 Hz. sample_column data file contains integer row numbers, sample_rate incorrectly estimated 1 Hz, defined explicitly. Columns rows contain entirely missing data (NA) omitted.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_invalid.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace Invalid Values — replace_invalid","title":"Replace Invalid Values — replace_invalid","text":"Detect specific values c(0, 100) vector data replaces NA local median value.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_invalid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace Invalid Values — replace_invalid","text":"","code":"replace_invalid(x, values, width, return = c(\"NA\", \"median\"))"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_invalid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace Invalid Values — replace_invalid","text":"x numeric vector values numeric vector values replaced, e.g. values = c(0, 100). width numeric scalar window length (2 · width + 1) samples. return Indicates whether outliers replaced NA (default) local \"median\" value.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_invalid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace Invalid Values — replace_invalid","text":"numeric vector filtered data.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_invalid.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Replace Invalid Values — replace_invalid","text":"Useful overwrite known invalid/nonsense values, 0, 100, 102.3. TODO: allow overwriting values greater less known values.","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_invalid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace Invalid Values — replace_invalid","text":"","code":"set.seed(13) (x <- sample.int(10, 20, replace = TRUE)) #>  [1]  8  3  5 10  6  6  4  8  3  1 10  7  7  5  1  6  8  1  1  4 (y <- replace_invalid(x, values = c(1, 10), width = 5)) #>  [1]  8  3  5 NA  6  6  4  8  3 NA NA  7  7  5 NA  6  8 NA NA  4"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace Missing Values — replace_missing","title":"Replace Missing Values — replace_missing","text":"Detect missing values vector data replace via methods zoo package.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace Missing Values — replace_missing","text":"","code":"replace_missing(   x,   method = c(\"linear\", \"locf\", \"spline\", \"omit\"),   na.rm = FALSE,   maxgap = Inf )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_missing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace Missing Values — replace_missing","text":"x numeric vector. method Indicates replace missing data. \"locf\" Stands 'last observation carried forward'. Replaces NA recent non-NA value prior via zoo::na.locf(). \"linear\" Replaces NA via linear interpolation via zoo::na.approx(). \"spline\" Replaces NA cubic spline interpolation via zoo::na.spline(). \"omit\" Removes NA via stats::na.omit(). na.rm logical. result interpolation still results leading /trailing NAs, removed (using na.trim)? maxgap numeric scalar maximum number consecutive NAs fill. longer gaps left unchanged.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_missing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace Missing Values — replace_missing","text":"numeric vector filtered data named numeric vector names indices original input vector.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_missing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Replace Missing Values — replace_missing","text":"function also replace NaN Inf NA. method = \"locf\" earlier non-NAs, NA either omitted (na.rm = TRUE) replaced (na.rm = FALSE). method = \"linear\" na.rm = TRUE extrapolate leading trailing NAs applying rule = 2 (see stats::approx()). na.rm = FALSE return leading/trailing NAs applying rule = 1. method = \"spline\" TODO method = \"omit\" returned vector y named vector original indices value names. allows preserving re-inserting omitted NAs back final dataset, needed.","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_missing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace Missing Values — replace_missing","text":"","code":"(x <- c(1, 2, NA, Inf, 5, 6, NA)) #> [1]   1   2  NA Inf   5   6  NA replace_missing(x, method = \"omit\") #> 1 2 5 6  #> 1 2 5 6  replace_missing(x, method = \"locf\") #> [1] 1 2 2 2 5 6 6 replace_missing(x, method = \"linear\", na.rm = FALSE) #> [1]  1  2  3  4  5  6 NA replace_missing(x, method = \"linear\", na.rm = TRUE) #> [1] 1 2 3 4 5 6 6"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_outliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace Local Outliers — replace_outliers","title":"Replace Local Outliers — replace_outliers","text":"Detect local outliers vector data Hampel filter using median absolute deviation (MAD), replaces local median value NA.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_outliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace Local Outliers — replace_outliers","text":"","code":"replace_outliers(x, width, t0 = 3, na.rm = FALSE, return = c(\"median\", \"NA\"))"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_outliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace Local Outliers — replace_outliers","text":"x numeric vector. width numeric scalar window length (2 × width + 1) samples. t0 numeric scalar outlier threshold, default 3 (Pearson's rule). na.rm logical indicating whether missing values ignored filter applied (see Details). return Indicates whether outliers replaced local \"median\" value (default), returned NA.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_outliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace Local Outliers — replace_outliers","text":"numeric vector filtered data.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_outliers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Replace Local Outliers — replace_outliers","text":"\"median absolute deviation\" computation done [-width...width] vicinity point least width steps away end points interval. lower upper end time series values preserved. high threshold makes filter forgiving, low one declare points outliers. t0 = 3 (default) corresponds Pearson's 3 sigma edit rule, t0 = 0 Tukey's median filter. NA values numeric vector cause error unless na.rm = TRUE. NA values skipped outlier detection, preserved returned vector. default return = \"median\" replace outliers local median value, pracma::hampel(). Otherwise, outliers returned NA (returns equally computationally expensive).","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/replace_outliers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace Local Outliers — replace_outliers","text":"","code":"set.seed(8421) x <- numeric(1024) z <- rnorm(1024) x[1] <- z[1] for (i in 2:1024) {     x[i] <- 0.4*x[i-1] + 0.8*x[i-1]*z[i-1] + z[i] } x[150:200] <- NA ## generate NA values # replace_outliers(x, width = 20, na.rm = FALSE) ## returns error y <- replace_outliers(x, width = 20, na.rm = TRUE) ind <- which(x != y) ## identify outlier indices outliers <- x[ind] ## identify outlier values  if (FALSE) { # \\dontrun{ plot(1:1024, x, type = \"l\") points(ind, outliers, pch = 21, col = \"darkred\") lines(y, col = \"blue\") } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rescale_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Rescale Data Range — rescale_data","title":"Rescale Data Range — rescale_data","text":"Resize range (min max values) data channels new dynamic range, preserving relative scaling across channels. e.g. rescale range data c(0,100).","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rescale_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rescale Data Range — rescale_data","text":"","code":"rescale_data(data, nirs_columns = list(), rescale_range = c(0, 100))"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rescale_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rescale Data Range — rescale_data","text":"data dataframe. nirs_columns list() character vectors indicating column names data channels rescaled (see Details). rescale_range numeric vector form c(min, max), indicating range output values data channels rescaled.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rescale_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rescale Data Range — rescale_data","text":"tibble class mNIRS.data metadata available attributes().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rescale_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rescale Data Range — rescale_data","text":"nirs_columns = list() can used group data columns preserve relative scaling. channels grouped together vector preserve relative scaling across channels. match column names dataframe exactly. nirs_columns = list(\"\", \"B\", \"C\") rescale column separately. Relative scaling lost data channels. nirs_columns = list(c(\"\", \"B\", \"C\")) rescale columns together. Relative scaling preserved across group data channels. nirs_columns = list(c(\"\", \"B\"), c(\"C\", \"D\")) rescale columns B together, columns C D together. Relative scaling preserved within group, across groups data channels.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rolling_slope.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Rolling Slope — rolling_slope","title":"Calculate Rolling Slope — rolling_slope","text":"Computes rolling first derivative (linear regression slope) numeric response variable y within moving window.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rolling_slope.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Rolling Slope — rolling_slope","text":"","code":"rolling_slope(   y,   x = seq_along(y),   width,   align = c(\"center\", \"left\", \"right\"),   na.rm = FALSE )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rolling_slope.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Rolling Slope — rolling_slope","text":"y numeric vector response variable. x numeric vector predictor variable, defaults using index x = seq_along(y). width numeric scalar defining window width units x rolling calculations. align Specifies window alignment width \"center\" (default), \"left\", \"right\". \"left\" forward looking, \"right\" backward looking window width current sample. na.rm logical indicating missing data handled. FALSE (default) perform complete case analysis return rolling slopes local y samples valid. TRUE return rolling slopes local target y sample valid.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rolling_slope.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Rolling Slope — rolling_slope","text":"numeric vector rolling local slopes units y/x length y.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rolling_slope.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Rolling Slope — rolling_slope","text":"Uses least squares formula complete case analysis calculate local slopes within rolling window along x specified width units x. .e. x = 10 include samples within 10-second window time series data.","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/rolling_slope.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Rolling Slope — rolling_slope","text":"","code":"y <- c(1, 3, 2, 5, 8, 7, 9, 12, 11, 15, 14, 17, 18) rolling_slope(y, width = 3) #>  [1] 2.0 0.5 1.0 3.0 1.0 0.5 2.5 1.0 1.5 1.5 1.0 2.0 1.0 rolling_slope(y, width = 3, align = \"left\") #>  [1] 1.1 1.8 1.8 1.1 1.4 1.5 1.7 1.0 1.7 1.2 2.0 1.0 0.0  y_na <- c(1, 3, NA, 5, 8, 7, 9, 12, NA, NA, NA, 17, 18) rolling_slope(y_na, width = 3) #>  [1] 2.0  NA  NA  NA 1.0 0.5 2.5  NA  NA  NA  NA  NA 1.0"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/scale_colour_my_palette.html","id":null,"dir":"Reference","previous_headings":"","what":"Scales for custom mNIRS palette — scale_colour_mNIRS","title":"Scales for custom mNIRS palette — scale_colour_mNIRS","text":"Scales custom mNIRS palette","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/scale_colour_my_palette.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scales for custom mNIRS palette — scale_colour_mNIRS","text":"","code":"scale_colour_mNIRS(...)  scale_fill_mNIRS(...)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/scale_colour_my_palette.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scales for custom mNIRS palette — scale_colour_mNIRS","text":"... Arguments passed discrete_scale.","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/shift_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift Data Range — shift_data","title":"Shift Data Range — shift_data","text":"Move range data channels dataframe , preserving absolute dynamic range /relative scaling across channels. e.g. shift data range positive values, shift first value recording zero.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/shift_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift Data Range — shift_data","text":"","code":"shift_data(   data,   nirs_columns = list(),   shift_to = 0,   position = c(\"minimum\", \"maximum\", \"first\"),   mean_samples = 1,   shift_by = NULL )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/shift_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift Data Range — shift_data","text":"data dataframe. nirs_columns list() character vectors indicating column names data channels shifted (see Details). shift_to numeric scalar specified data channels shifted . position Indicates shift values. \"minimum\" shift selected channels' minimum values specified shift_to value (default). \"maximum\" shift selected channels maximum values. \"first\" shift selected channels first values. mean_samples integer scalar representing number samples position determined. e.g., mean_samples = 1 looks single minimum, maximum, first value. mean_samples = 30 use mean lowest, highest, first 30 samples. shift_by optional numeric scalar data signals can shifted set amount.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/shift_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift Data Range — shift_data","text":"tibble class mNIRS.data metadata available attributes().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/shift_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Shift Data Range — shift_data","text":"nirs_columns = list() can used group data columns preserve absolute relative scaling. channels grouped together vector preserve relative scaling across channels. match column names dataframe exactly. nirs_columns = list(\"\", \"B\", \"C\") shift column separately. Absolute dynamic range data channel preserved, relative scaling lost data channels. nirs_columns = list(c(\"\", \"B\", \"C\")) shift columns together. Absolute dynamic range relative scaling preserved across group data channels. nirs_columns = list(c(\"\", \"B\"), c(\"C\", \"D\")) shift columns B together, columns C D together. Absolute dynamic range relative scaling preserved within group, across groups data channels.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/signif_trailing.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a numeric value as character with trailing zeroes — signif_trailing","title":"Print a numeric value as character with trailing zeroes — signif_trailing","text":"Converts numeric character object preserve trailing zeroes display.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/signif_trailing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a numeric value as character with trailing zeroes — signif_trailing","text":"","code":"signif_trailing(x, digits = 2, format = c(\"digits\", \"signif\"))"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/signif_trailing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a numeric value as character with trailing zeroes — signif_trailing","text":"x numeric vector. digits integer scalar specifying number digits preserve. format Indicates treat digits. Either desired number digits decimal point (format = \"digits\") significant digits (format = \"signif\").","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/signif_trailing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print a numeric value as character with trailing zeroes — signif_trailing","text":"character vector.","code":""},{"path":[]},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/signif_trailing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print a numeric value as character with trailing zeroes — signif_trailing","text":"","code":"x <- c(1, 1.3, 1.35) signif_trailing(x, digits = 2, format = \"digits\") #> [1] \"1.00\" \"1.30\" \"1.35\" signif_trailing(x, digits = 2, format = \"signif\") #> [1] \"1.0\" \"1.3\" \"1.4\""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/slope.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Slope of a Numeric Vector — slope","title":"Calculate the Slope of a Numeric Vector — slope","text":"Computes linear regression slope numeric response variable y.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/slope.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Slope of a Numeric Vector — slope","text":"","code":"slope(y, x = seq_along(y))"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/slope.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Slope of a Numeric Vector — slope","text":"y numeric vector response variable. x numeric vector predictor variable, defaults using index x = seq_along(y).","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/slope.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the Slope of a Numeric Vector — slope","text":"numeric slope value y/x.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/slope.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the Slope of a Numeric Vector — slope","text":"Uses least squares formula complete case analysis. single valid observation return NA.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/slope.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the Slope of a Numeric Vector — slope","text":"","code":"if (FALSE) { # \\dontrun{ y <- c(1, 3, 2, 5, 8, 7, 9, 12, 11, 15, 14, 17, 18) slope(y)  y <- c(1, 3, NA, 5, 8, 7, 9, 12, NA, NA, NA, 17, NA) slope(y) } # }"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/theme_mNIRS.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom mNIRS ggplot2 theme — theme_mNIRS","title":"Custom mNIRS ggplot2 theme — theme_mNIRS","text":"ggplot2 theme display.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/theme_mNIRS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom mNIRS ggplot2 theme — theme_mNIRS","text":"","code":"theme_mNIRS(   base_size = 14,   base_family = \"sans\",   border = c(\"partial\", \"full\"),   ... )"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/theme_mNIRS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Custom mNIRS ggplot2 theme — theme_mNIRS","text":"base_size Base font size, given pts. base_family Base font family. border Define either partial full border around plots. ... Additional arguments add theme().","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/theme_mNIRS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Custom mNIRS ggplot2 theme — theme_mNIRS","text":"ggplot2 object.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/update_fixed_coefs.html","id":null,"dir":"Reference","previous_headings":"","what":"Update a model object with Fixed coefficients — update_fixed_coefs","title":"Update a model object with Fixed coefficients — update_fixed_coefs","text":"Re-fit model fixed coefficients provided additional arguments. Fixed coefficients modified optimising best fit.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/update_fixed_coefs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update a model object with Fixed coefficients — update_fixed_coefs","text":"","code":"update_fixed_coefs(model, ...)"},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/update_fixed_coefs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update a model object with Fixed coefficients — update_fixed_coefs","text":"model existing model object lm, nls, glm, many others. ... Additional arguments define fixed coefficients.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/update_fixed_coefs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update a model object with Fixed coefficients — update_fixed_coefs","text":"model object.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/update_fixed_coefs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Update a model object with Fixed coefficients — update_fixed_coefs","text":"additional arguments left blank, coefficient exist model, model returned unchanged.","code":""},{"path":"https://jemarnold.github.io/mNIRS.dev/reference/update_fixed_coefs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update a model object with Fixed coefficients — update_fixed_coefs","text":"","code":"if (FALSE) { # \\dontrun{ Chick.1 <- datasets::ChickWeight[datasets::ChickWeight$Chick == 1, ] SSlogis(Chick.1$Time, Asym = 368, xmid = 14, scal = 6) (model <- nls(weight ~ SSlogis(Time, Asym, xmid, scal), data = Chick.1)) (model_fixed <- update_fixed_coefs(model, xmid = 20))  plot(Chick.1$Time, Chick.1$weight, type = \"o\", pch = 16,      xlab = \"Time\", ylab = \"weight\") lines(Chick.1$Time, fitted(model), col = \"red\", lwd = 2) lines(Chick.1$Time, fitted(model_fixed), col = \"blue\", lwd = 2) legend(\"topleft\", legend = c(\"Observed\", \"model\", \"model_fixed\"),        col = c(\"black\", \"red\", \"blue\"),        pch = c(16, NA, NA),        lwd = c(1, 2, 2)) } # }"}]
